/* eslint-disable camelcase */
'use strict';

module.exports = {
    title: 'XR',
    description: 'XR related nodes and components',
    xrui: 'XRUI',
    rendering_scale: 'Adjust the rendering scale',
    msaa: 'Adjust the number of pixels that MultiSampling Anti-Aliasing takes part in the calculation',
    node: {
        convert_main_camera_to_xr_hmd: 'Convert Main Camera To XR HMD',
        xr_agent: 'XR Agent',
        xr_hmd: 'XR HMD',
        ray_interactor: 'Ray Interactor',
        direct_interactor: 'Direct Interactor',
        locomotion_checker: 'Locomotion Checker',
        teleportable: 'Teleportable',
        simple_interactable: 'Simple Interactable',
        grab_interactable: 'Grab Interactable',
        button: 'Button',
        editBox: 'EditBox',
        layout: 'Layout',
        pageView: 'PageView',
        progressBar: 'ProgressBar',
        richText: 'RichText',
        scrollView: 'ScrollView',
        slider: 'Slider',
        toggle: 'Toggle',
        toggleGroup: 'ToggleGroup',
        videoPlayer: 'VideoPlayer',
        webView: 'WebView',
        widget: 'Widget',
        sprite: 'Sprite',
        label: 'Label',
    },
    hmd_ctrl: {
        perEyeCamera: 'Whether to open separate left and right eye nodes',
        syncWithMainCamera: 'Left and right eye nodes set whether to synchronize the main camera',
        IPDOffset: 'Whether to open to set Interpupillary distance',
        offsetValue: 'Value of interpupillary distance',
    },
    pose_tracker: {
        trackingSource: 'Specify the physical device to trace',
        trackingType: 'Device tracking mode, effective tracking variable',
    },
    target_eye: {
        targetEye: 'Target camera for rendering',
    },
    tracking_origin: {
        offsetObject: 'The node which need to offset',
        trackingOriginMode: 'Tracing migration mode',
        yOffsetValue: 'The offsetObject offset in the Y axis',
    },
    xr_controller: {
        inputDevice: 'Binding of physical input devices',
        selectActionLeft: 'Select state input key bindings (left)',
        activateActionLeft: 'Active input key bindings (left)',
        UIPressActionLeft: 'UiPress key bindings (left)',
        selectActionRight: 'Select state input key bindings (right)',
        activateActionRight: 'Active input key bindings (right)',
        UIPressActionRight: 'UiPress key bindings (right)',
        axisToPressThreshold: 'Minimum threshold for triggering behavior',
        model: 'Bind visual model of Controller',
    },
    xr_interactive_simulator: {
        xrAgent: 'Bind XR Agent. The default bind is the first XR Agent that is iterated over the current scene',
    },
    interactable_events: {
        hoverEnterEvents: 'Hover start event',
        hoverStayEvents: 'Hover stay event',
        hoverExitEvents: 'Hover end event',
        selectEnterEvents: 'Select start event',
        selectStayEvents: 'Select stay event',
        selectExitEvents: 'Select end event',
        activeEnterEvents: 'Activation start event',
        activeStayEvents: 'Activation stay event',
        activeExitEvents: 'Activation end event',
    },
    interactor_events: {
        audioEvents: 'Audio trigger event',
        hapticEvents: 'Tactile triggering event',
        interactorEvents: 'Interaction events',
        audio_events: {
            onSelectEntered: 'Whether to enable the trigger audio that selects the start event',
            onSelectEnteredAudioClip: 'Select the trigger audio for the start event',
            onSelectStay: 'Whether to enable the trigger audio that selects the stay event',
            onSelectStayAudioClip: 'Select the trigger audio for the stay event',
            onSelectExited: 'Whether to enable the trigger audio for the select end event',
            onSelectExitedAudioClip: 'Select the trigger audio that ends the event',
            onHoverEntered: 'Whether to enable the trigger audio for the hover start event',
            onHoverEnteredAudioClip: 'Trigger audio for the hover start event',
            onHoverStay: 'Whether to enable the trigger audio for the hover stay event',
            onHoverStayAudioClip: 'Trigger audio for the hover stay event',
            onHoverExited: 'Whether to enable the trigger audio for the hover end event',
            onHoverExitedAudioClip: 'Trigger audio for the hover end event',
        },
        sub_interactor_events: {
            hoverEnterEvents: 'Hover start event',
            hoverStayEvents: 'Hover stay event',
            hoverExitEvents: 'Hover ends the event',
            selectEnterEvents: 'Select start event',
            selectStayEvents: 'Select stay event',
            selectExitEvents: 'Select end event',
        },
    },
    xr_interactor: {
        attachTransform: 'Instead of the final position of the captured object, if empty, use the position of the current Interactor',
        selectActionTrigger: 'Select the triggering mechanism for the behavior',
    },
    ray_interactor: {
        forceGrab: 'When enabled, the captured object is attached to the AttachTransform, and when closed, the position attached to the interaction point is captured',
        rayOriginTransform: 'The position from which Ray is emitted, null defaults to the position of the current Interactor',
        maxRayDistance: 'The furthest distance a ray can be projected',
        reticle: 'Ray cursor',
    },
    xr_interactable: {
        rayReticle: 'When a ray touches an interaction, a reminder of the contact point display',
    },
    grab_interactable: {
        attachTransform: 'Use the position of this AttachTransform as the position at which the object is fetched, or if it is empty use the position of the actual object (possibly a position of the object being fetched)',
        attachEaseInTime: 'The time consumed by the migration process of the captured object',
        grabTrigger: 'The event that triggers fetching',
        hideController: 'Whether to hide the XR Controller object model. Hide the XR Controller object model when enabled',
        throwOnDetach: 'When turned on, the object has physical properties that simulate the throwing behavior',
        throwSimulationMode: 'The calculation of the velocity of an object when thrown',
        throwSmoothingDuration: 'The time period used to calculate the average throwing speed',
        throwSmoothingCurve: 'The curve to use to weight thrown velocity smoothing (most recent frames to the right)',
        throwVelocityScale: 'The multiplier of speed inherited from the interactor during throwing',
        throwAngularVelocityScale: 'The multiplier of angular velocity inherited from the interactor during throwing',
    },
    teleportable: {
        teleportableType: 'Teleport type, teleport point and teleport area',
        teleportAnchorNode: 'This is enabled when the transport type is transport point. Defines the fixed location of the final transmission',
        teleportTrigger: 'The event that triggers the transport',
        teleporter: 'A transport object that can be transported to this point',
    },
    locomotion_base: {
        checker: 'Select to specify a Locomotion Checker, or if the user does not specify it, the default binding traverses the current sence and obtains the first Locomotion Checker',
        inputDevice: 'Bind the input device that needs to read the signal',
        inputControl: 'Binding input controls',
    },
    continuous_mover: {
        moveSpeed: 'Speed of movement',
        forwardSource: 'An object specified as a forward direction',
    },
    continuous_turner: {
        turnSpeed: 'Speed of turning',
    },
    sharp_turner: {
        turnAngle: 'Fixed steering Angle each time',
        enableTurnAround: 'This allows XR Agent to rotate 180 degrees when the joystick is pressed',
        activationTimeout: 'The time required to wait while performing a continuous turn',
    },
    locomotion_checker: {
        xrAgent: 'Bind XR Agent. The default bind is the first XR Agent that is iterated over the current scene',
    },
    teleporter: {
        checker: 'Select to specify a Locomotion Checker, or if the user does not specify it, the default binding traverses the current sence and obtains the first Locomotion Checker',
    },
    camera_following: {
        camera: 'Select the camera the UI wants to follow',
    },
    raycast_checker: {
        ignoreReversedUI: 'When enabled, it cannot interact with the reverse UI control',
    },
    xr_key: {
        key: 'The value of the key on the virtual keyboard',
    },
    xr_keyboard_input_field: {
        suspendTransform: 'XR keyboard floating position',
        xRKeyboard: 'Select the virtual keyboard object you want to reference (cc.xrkeyboard must be added)',
    },
    xr_keyboard: {
        disableUIInteractionWhenTyping: 'Whether to disable user interaction with other UI elements while typing. Use this option to reduce the chance of the keyboard being shut down unexpectedly.',
        onCommitText: 'Submit a callback for input text events',
        onShowKeyboard: 'Show callbacks for XR keyboard events',
        onHideKeyboard: 'Hide callbacks for XR keyboard events',
    },
    xr_switch: {
        switch_latin: 'Key of latin keyboard',
        switch_symbol: 'Key of symbol keyboard',
        switch_math_symbol: 'Key of scientific calculation keyboard',
    },
    document: {
        agree: 'agree',
        disagree: 'disagree',
    },
};
